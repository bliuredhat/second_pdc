require 'test_helper'

class PushJobTest < ActiveSupport::TestCase
  setup do
    @active_status = ['RUNNING','READY','QUEUED','WAITING_ON_PUB']
    @inactive_status = ['COMPLETE','FAILED', 'POST_PUSH_PROCESSING']

    prepare_ovalcache

    pushready = Errata.push_ready
    @cdn_rhn_pushable = pushready.select{|e| e.supports_cdn? && e.supports_rhn_live?}.first
    @cdn_only_pushable = pushready.select{|e| e.supports_cdn? && !e.supports_rhn_live?}.first
    @rhn_only_pushable = pushready.select{|e| !e.supports_cdn? && e.supports_rhn_live?}.first
  end

  # Returns a push job in an appropriate state to start running post-push tasks
  def job_ready_for_post_push_tasks
    pj = PushJob.find(37571)

    # Start with empty log, and ready to run tasks
    pj.update_attributes(:log => '', :status => 'POST_PUSH_PROCESSING')

    # Arbitrary realistic set of tasks
    pj.post_push_tasks = %w[update_jira move_pushed_errata request_translation
                            update_push_count update_bugzilla]

    pj.save!

    pj
  end

  test "push job in progress" do
    job = PushJob.first
    @active_status.each do |status|
      job.status = status
      assert job.in_progress?
    end

    @inactive_status.each do |status|
      job.status = status
      refute job.in_progress?
    end
  end

  test "push job failed" do
    job = PushJob.first

    job.status = 'FAILED'
    assert job.failed?

    job.status = 'COMPLETE'
    refute job.failed?
  end

  test "get active push jobs" do
    assert PushJob.active_jobs.empty?, "Fixture error: PushJob is no longer have empty active job"

    all_status = @active_status + @inactive_status
    jobs = PushJob.all.take(all_status.size)

    all_status.each_with_index do |status, i|
      jobs[i].status = status
      jobs[i].save!
    end

    assert_equal jobs.first(@active_status.size).sort_by(&:id), PushJob.active_jobs.sort_by(&:id)
  end

  test "submit immediately saves the task ID" do
    pj = PushJob.find(35510)

    refute pj.pub_task_id

    pj.submit!

    # It is not required to do an additional save for the pub task ID to be
    # persisted.  This is important since pub may call back to ET with the task
    # ID very quickly.
    # (This is the first task ID generated by the pub client used in tests,
    # see DummyClient.)
    pj.reload
    assert_equal 100_000, pj.pub_task_id
  end

  test 'submit_later submits via delayed job' do
    pj = unsubmitted_push_job
    refute pj.pub_task_id

    delayed_jobs = capture_delayed_jobs do
      pj.submit_later
    end

    refute pj.reload.pub_task_id

    assert_equal 1, delayed_jobs.length

    delayed_jobs[0].perform

    # Delayed job should have created the pub task
    pj.reload
    assert_equal 100_000, pj.pub_task_id
  end

  test 'submit_later bails out if job status changed' do
    pj = unsubmitted_push_job
    refute pj.pub_task_id

    delayed_jobs = capture_delayed_jobs do
      pj.submit_later
    end

    refute pj.reload.pub_task_id

    assert_equal 1, delayed_jobs.length

    # If the job status now becomes something else, the delayed job will skip
    # submitting the pub task.  Most common case would be that a user cancelled
    # the job.
    pj.status = 'FOO'
    pj.save!

    delayed_jobs[0].perform

    pj.reload
    refute pj.pub_task_id

    # Should be something in log about it
    assert_match 'Not submitting to pub because status is FOO', pj.log
  end

  test 'submit_later can submit CDN depending on RHN status' do
    e = Errata.find(16616)

    # Base state: advisory is ready for push to RHN and CDN.
    assert e.can_push_rhn_live?
    assert e.can_push_cdn_if_live_push_succeeds?

    # It cannot directly push to CDN though (have to push with or after RHN...)
    refute e.can_push_cdn?

    # It has not pushed to either previously.
    assert RhnLivePushJob.for_errata(e).empty?
    assert CdnPushJob.for_errata(e).empty?

    make_job = lambda do |klass|
      job = klass.new(:errata => e, :pushed_by => User.system,
                      :pub_options => {'push_files'=> true, 'push_metadata' => true})
      # (Need to set this explicitly, normally done during validation...)
      job.push_target = e.push_target_for_push_type(job.push_type)
      # Intentionally bypass validation here because we are preparing an unlikely
      # situation to verify that validation happens (again) appropriately just before
      # pub task is submitted
      job.save!(:validate => false)
      job
    end

    cdn_job = make_job[CdnPushJob]

    # Check what would happen if CDN were submitted via submit_later (but roll it back).
    # Returns the job attributes.
    pretend_submit_cdn = lambda do
      out = nil
      ActiveRecord::Base.transaction do
        force_sync_delayed_jobs do
          cdn_job.submit_later
        end

        out = cdn_job.reload.attributes

        raise ActiveRecord::Rollback
      end
      out
    end

    refute_can_submit = lambda do
      result = pretend_submit_cdn[]

      refute result['pub_task_id']
      assert_equal 'FAILED', result['status']

      assert_match('no longer eligible for push: Advisory has not been shipped to rhn',
                   result['log'])
    end

    assert_can_submit = lambda do
      result = pretend_submit_cdn[]
      assert result['pub_task_id'], "Could not submit! Log:\n#{result['log']}"
      assert_equal 'WAITING_ON_PUB', result['status']
    end

    # Initially, it will not be able to submit, since there is no RHN push job
    refute_can_submit[]

    rhn_job = make_job[RhnLivePushJob]

    # Now there is an RHN job, so it should be OK to submit CDN
    assert_can_submit[]

    # It would also be OK to submit CDN if RHN had completed.
    force_sync_delayed_jobs do
      rhn_job.submit_later
    end
    rhn_job.pub_success!

    assert_can_submit[]

    # But it wouldn't be OK if RHN had failed.
    rhn_job.mark_as_failed!('simulated error')

    refute_can_submit[]
  end

  test 'submit_later fails job if errata becomes invalid for push' do
    pj = unsubmitted_push_job
    refute pj.pub_task_id

    delayed_jobs = capture_delayed_jobs do
      pj.submit_later
    end

    assert_equal 1, delayed_jobs.length

    # If the advisory status changed meanwhile, don't submit push job.
    pj.errata.change_state!('REL_PREP', User.system)

    delayed_jobs[0].perform

    pj.reload
    refute pj.pub_task_id
    assert_equal 'FAILED', pj.status

    # Should be something in log about it
    assert_match(
      'Cancelling, errata no longer eligible for push: State REL_PREP invalid.',
      pj.log)
  end

  test "Failed Submit to Pub" do
    e = RHBA.push_ready.first
    assert e.can_push_rhn_live?, e.push_rhn_live_blockers.join(',')
    j = RhnLivePushJob.new(:errata => e, :pushed_by => User.system)
    assert j.valid?, j.errors.full_messages.join(', ')
    j.set_defaults
    j.save!

    pc = Push::PubClient.get_connection
    assert_equal Push::DummyClient, pc.class
    pc.should_fail = true
    ex = assert_raise(RuntimeError) { j.create_pub_task(pc) }
    assert_equal 'Unable to get a task id from Pub; submission failed', ex.message
    assert_equal 'FAILED', j.status

    # Ensure advisory went into IN_PUSH, moved to PUSH_READY when pub failed
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::PUSH_READY, e.status
  end

  test "Failed RHSA push" do
    e = RHSA.push_ready.first
    assert e.can_push_rhn_live?, e.push_rhn_live_blockers.join(',')
    j = RhnLivePushJob.new(:errata => e, :pushed_by => User.system)
    assert j.valid?, j.errors.full_messages.join(', ')
    j.set_defaults
    j.save!

    pc = Push::PubClient.get_connection
    assert_equal Push::DummyClient, pc.class
    pc.should_fail = true
    ex = assert_raise(RuntimeError) { j.create_pub_task(pc) }
    assert_equal 'Unable to get a task id from Pub; submission failed', ex.message
    assert_equal 'FAILED', j.status

    # Ensure advisory went into IN_PUSH, moved to PUSH_READY when pub failed
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::PUSH_READY, e.status
  end

  test "IN_PUSH error" do
    e = RHBA.push_ready.first

    assert e.can_push_rhn_live?, e.push_rhn_live_blockers.join(',')
    j = RhnLivePushJob.new(:errata => e, :pushed_by => User.system)
    assert j.valid?, j.errors.full_messages.join(', ')
    j.set_defaults
    j.save!

    def j.task_set_in_push
      raise "FAIL IN_PUSH"
    end
    pc = Push::PubClient.get_connection
    assert_equal Push::DummyClient, pc.class

    ex = assert_raise(RuntimeError) { j.create_pub_task(pc) }
    assert_equal 'FAIL IN_PUSH', ex.message
    assert_equal 'FAILED', j.status

    # Ensure advisory remained in PUSH_READY
    assert_equal State::PUSH_READY, e.status
  end

  test "live id error" do
    e = RHBA.push_ready.first
    assert e.can_push_rhn_live?, e.push_rhn_live_blockers.join(',')
    j = RhnLivePushJob.new(:errata => e, :pushed_by => User.system)
    assert j.valid?, j.errors.full_messages.join(', ')
    j.set_defaults
    j.save!

    def e.set_fulladvisory
      raise 'FAIL SET LIVE ID'
    end
    pc = Push::PubClient.get_connection
    assert_equal Push::DummyClient, pc.class

    ex = assert_raise(RuntimeError) { j.create_pub_task(pc) }
    assert_equal 'FAIL SET LIVE ID', ex.message
    assert_equal 'FAILED', j.status

    # Ensure advisory moved back to PUSH_READY
    assert_equal State::PUSH_READY, e.status
  end

  test 'Pub RHN Live Push Failed' do
    e = RHBA.push_ready.first
    assert e.can_push_rhn_live?, e.push_rhn_live_blockers.join(',')
    j = RhnLivePushJob.new(:errata => e, :pushed_by => User.system)
    assert j.valid?, j.errors.full_messages.join(', ')
    j.set_defaults
    j.save!

    pc = Push::PubClient.get_connection
    assert_equal Push::DummyClient, pc.class
    j.create_pub_task(pc)
    assert_equal 'WAITING_ON_PUB', j.status

    # Assert advisory transition PUSH_READY => IN_PUSH
    assert_equal State::PUSH_READY, e.current_state_index.previous
    assert_equal State::IN_PUSH, e.status

    j.mark_as_failed!("Pub task failed")
    assert_equal 'FAILED', j.status

    # Assert advisory transition IN_PUSH => PUSH_READY
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::PUSH_READY, e.status
  end

  test 'Pub RHN Live Push Succeeded' do
    e = Errata.push_ready.select{|e| e.supports_rhn_live? && !e.supports_cdn?}.first
    prepare_oval_test

    assert e.can_push_rhn_live?, e.push_rhn_live_blockers.join(',')
    j = RhnLivePushJob.new(:errata => e, :pushed_by => User.system)
    assert j.valid?, j.errors.full_messages.join(', ')
    j.set_defaults
    j.save!

    expected_old_advisory = "RHSA-2011:11110-02"
    assert_equal expected_old_advisory, e.fulladvisory

    pc = Push::PubClient.get_connection
    assert_equal Push::DummyClient, pc.class
    j.create_pub_task(pc)
    e.reload
    assert_equal 'WAITING_ON_PUB', j.status

    # Assert advisory transition PUSH_READY => IN_PUSH
    assert_equal State::PUSH_READY, e.current_state_index.previous
    assert_equal State::IN_PUSH, e.status

    j.pub_success!
    e.reload
    assert_equal 'COMPLETE', j.status
    # Assert advisory transition IN_PUSH => SHIPPED_LIVE
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::SHIPPED_LIVE, e.status
    assert_equal expected_old_advisory, e.old_advisory

    e.reload
    la = e.live_advisory_name
    assert_not_nil la
    assert_equal "RHSA-#{la.year}:#{sprintf('%.4d', la.live_id)}-02", e.fulladvisory
    assert_oval_file(e)
  end

  test "job skips post-push tasks if cancelled before start" do
    PushJob.any_instance.expects(:run_task).never

    pj = job_ready_for_post_push_tasks
    pub = Push::PubClient.get_connection

    # If the job is cancelled by a user, run_post_push_tasks shouldn't do much
    pj.cancel!(pub, User.system)
    pj.run_post_push_tasks(pj.post_push_tasks)

    assert_equal 'FAILED', pj.status
    assert pj.log.ends_with?('Post-push tasks not run because job status is FAILED.')
  end

  test "job skips rest of post-push tasks if cancelled while running" do
    pj = job_ready_for_post_push_tasks

    pj.singleton_class.send(:define_method, :task_move_pushed_errata) do
      pj.info "Simulating state change."
      PushJob.find(pj.id).update_attributes(:status => 'QUUX')
    end

    pj.run_post_push_tasks(pj.post_push_tasks)

    pj.reload

    assert_equal 'QUUX', pj.status

    # drop timestamps in log
    log = pj.log.lines.map{|line| line.split.drop(3).join(' ')}.join("\n")

    assert log.ends_with?(<<'END'.strip_heredoc.strip), log
      Running task move_pushed_errata
      Simulating state change.
      Post-push processing was interrupted.
END
  end

  def assert_oval_file(errata)
    year = errata.live_advisory_name.year
    id = sprintf("%.4d", errata.live_advisory_name.live_id)
    oval_filename = Rails.root.join(Push.oval_conf.file_path, "com.redhat.rhsa-#{year}#{id}.xml")
    idx_update_filename = Rails.root.join(Push.oval_conf.file_path, ".needindexupdate")
    expected_oval_filename = "#{Rails.root}/test/data/errata_oval_baseline/com.redhat.rhsa-#{errata.id}.xml"

    refute File.zero?(oval_filename), "oval file should not be empty"
    assert File.zero?(idx_update_filename), "needindexupdate file should be empty"

    # make sure the content is correct
    assert_testdata_equal expected_oval_filename, IO.read(oval_filename)
  end

  def prepare_oval_test
    # stubs oval configs
    Push::OvalConf.stubs(:config).returns(OvalTest)
    # current time is used as a timestamp in oval output
    Time.stubs(:now => Time.gm(2012, 12, 12, 12, 12, 12))
    # test oval push
    ProductVersion.any_instance.expects(:is_oval_product?).at_least_once.returns(true)
    # make sure we don't do real push
    refute Push.oval_conf.xmlrpc_enabled
  end

  def with_post_push_test_tasks
    LivePushTasks::POST_PUSH_TASKS.merge!(post_push_test_tasks)
    begin
      yield
    ensure
      LivePushTasks::POST_PUSH_TASKS.except!(*post_push_test_tasks.keys)
    end
  end

  def post_push_test_tasks
    {
      'test_after_rhn' => {
        :mandatory   => true,
        :shadow      => true,
        :description => "Test; should execute once RHN push succeeds",
        :after       => :rhn_live,
      },
      'test_after_cdn' => {
        :mandatory   => true,
        :shadow      => true,
        :description => "Test; should execute once CDN push succeeds",
        :after       => :cdn,
      },
      'test_only_rhn' => {
        :mandatory   => true,
        :shadow      => true,
        :description => "Test; should execute for RHN only",
        :only        => :rhn_live,
      },
      'test_only_cdn' => {
        :mandatory   => true,
        :shadow      => true,
        :description => "Test; should execute for CDN only",
        :only        => :cdn,
      },
      'test_after_both' => {
        :mandatory   => true,
        :shadow      => true,
        :description => "Test; should execute once both RHN and CDN pushes succeed",
        :after       => [:rhn_live,:cdn],
      },
      'test_after_any' => {
        :mandatory   => true,
        :shadow      => true,
        :description => "Test; should execute once any push succeeds",
      },
    }
  end

  def do_rhn_cdn_push_task_test(opts)
    with_post_push_test_tasks do
      e = opts[:errata]
      mock_errata_product_listing(e)

      jobs = Array.wrap(opts[:create_jobs]).each_with_object({}) do |type,out|
        out.merge!(type => create_push_job(e, type == :rhn ? RhnLivePushJob : CdnPushJob))
      end
      refute jobs.empty?, 'need at least one job to test post-push tasks'
      e.reload

      # Assert advisory transition PUSH_READY => IN_PUSH
      assert_equal State::PUSH_READY, e.current_state_index.previous
      assert_equal State::IN_PUSH, e.status

      post_push_test_tasks.keys.map(&:to_sym).each do |task|
        jobs.each do |type, job|
          meth = "task_#{task}"
          exp = job.expects(meth)
          if Array.wrap(opts[:expected_tasks][type]).include?(task)
            exp.once
          else
            exp.never
          end
        end
      end

      Array.wrap(opts[:complete_jobs]).each do |type|
        jobs[type].pub_success! if jobs[type]
      end
    end
  end

  test 'rhn after' do
    do_rhn_cdn_push_task_test(
      :errata => @cdn_rhn_pushable,
      :create_jobs => [:rhn,:cdn],
      :complete_jobs => :rhn,
      :expected_tasks => {:rhn => [:test_after_rhn, :test_after_any, :test_only_rhn]})

    # Log should reflect ran / skipped tasks
    log = RhnLivePushJob.last.log

    assert_match    'Running task test_after_rhn', log
    assert_no_match /Running task test_after_cdn/, log
    assert_match(
      'Skipping task test_after_cdn: cdn push is not complete. Depends on: cdn',
      log)
    assert_match(
      'Skipping task test_after_both: cdn push is not complete. Depends on: cdn, rhn_live',
      log)
  end

  test 'cdn after' do
    do_rhn_cdn_push_task_test(
      :errata => @cdn_rhn_pushable,
      :create_jobs => [:rhn,:cdn],
      :complete_jobs => :cdn,
      :expected_tasks => {:cdn => [:test_after_cdn, :test_after_any, :test_only_cdn]})
  end

  test 'rhn cdn after' do
    do_rhn_cdn_push_task_test(
      :errata => @cdn_rhn_pushable,
      :create_jobs => [:rhn,:cdn],
      :complete_jobs => [:rhn,:cdn],
      :expected_tasks => {
        :rhn => [:test_after_any, :test_after_rhn, :test_only_rhn],
        :cdn => [:test_after_any, :test_after_rhn, :test_after_cdn, :test_after_both, :test_only_cdn]
      }
    )
  end

  test 'cdn rhn after' do
    do_rhn_cdn_push_task_test(
      :errata => @cdn_rhn_pushable,
      :create_jobs => [:rhn,:cdn],
      :complete_jobs => [:cdn,:rhn],
      :expected_tasks => {
        :cdn => [:test_after_any, :test_after_cdn, :test_only_cdn],
        :rhn => [:test_after_any, :test_after_cdn, :test_after_rhn, :test_after_both, :test_only_rhn]
      }
    )

    rhn_log = RhnLivePushJob.last.log
    cdn_log = CdnPushJob.last.log

    # Since CDN job finished first, it should have skipped several tasks which
    # were subsequently run by the RHN job
    assert_match(
      'Skipping task test_after_rhn: rhn_live push is not complete. Depends on: rhn_live',
      cdn_log)
    assert_match 'Running task test_after_rhn', rhn_log

    assert_match(
      'Skipping task test_after_both: rhn_live push is not complete. Depends on: cdn, rhn_live',
      cdn_log)
    assert_match 'Running task test_after_both', rhn_log
  end

  # Bug 1152401: Post-push tasks declared as after RHN and CDN should
  # be executed after RHN push when the advisory supports CDN but has
  # no active CDN repos.
  test 'rhn and cdn supported but no active cdn repos' do
    e = Errata.find(19028)
    assert e.supports_cdn?
    refute e.release_versions_used_by_advisory.
        map(&:active_cdn_repos).flatten.any?

    do_rhn_cdn_push_task_test(
      :errata => e,
      :create_jobs => [:rhn],
      :complete_jobs => [:rhn],
      :expected_tasks => {
        :rhn => [:test_after_any, :test_after_cdn, :test_after_rhn, :test_after_both, :test_only_rhn]
      })
  end

  test 'rhn omit cdn after' do
    do_rhn_cdn_push_task_test(
      :errata => @cdn_rhn_pushable,
      :create_jobs => :rhn,
      :complete_jobs => :rhn,
      :expected_tasks => {
        :rhn => [:test_after_any, :test_after_rhn, :test_only_rhn]
      }
    )
  end

  test 'rhn only after' do
    do_rhn_cdn_push_task_test(
      :errata => @rhn_only_pushable,
      :create_jobs => :rhn,
      :complete_jobs => :rhn,
      :expected_tasks => {
        :rhn => [:test_after_any, :test_after_rhn, :test_after_cdn, :test_after_both, :test_only_rhn]
      }
    )
  end

  test 'cdn only after' do
    do_rhn_cdn_push_task_test(
      :errata => @cdn_only_pushable,
      :create_jobs => :cdn,
      :complete_jobs => :cdn,
      :expected_tasks => {
        :cdn => [:test_after_any, :test_after_rhn, :test_after_cdn, :test_after_both, :test_only_cdn]
      }
    )
  end

  assert_no_error_logs instance_methods.grep(/^test_.*_after$/)

  test 'cannot create with non-valid push tasks or options' do
    RhnLivePushJob.any_instance.stubs(
      :valid_pre_push_tasks => {},
      :valid_post_push_tasks => {},
      :valid_pub_options => {}
    )
    pj = RhnLivePushJob.create(
      :errata => @cdn_rhn_pushable,
      :pushed_by => User.system,
      :pre_push_tasks => %w[set_in_push set_live_id],
      :post_push_tasks => %w[update_push_count update_bugzilla],
      :pub_options => {'opt1' => true, 'opt2' => false}
    )
    refute pj.valid?

    %w[set_in_push set_live_id update_push_count update_bugzilla].each do |task|
      assert pj.errors[:base].include?("Task '#{task}' is not a valid task for this push job"), "task #{task} incorrectly validated"
    end

    %w[opt1 opt2].each do |opt|
      assert pj.errors[:options].include?("Option '#{opt}' is not a valid option for this push job"), "option #{opt} incorrectly validated"
    end
  end

  test 'tasks and options are not revalidated for existing job' do
    pj = RhnLivePushJob.create!(
      :errata => @cdn_rhn_pushable,
      :pushed_by => User.system
    )
    # creating using the default tasks/options should be fine
    assert_valid pj
    assert pj.pre_push_tasks.any?
    assert pj.post_push_tasks.any?
    assert pj.pub_options.any?

    # if the values of valid_* change, the record should still be considered valid,
    # as these should only be used at creation time
    RhnLivePushJob.any_instance.stubs(
      :valid_pre_push_tasks => {},
      :valid_post_push_tasks => {},
      :valid_pub_options => {}
    )

    pj.mark_as_running!
  end

  test 'job with removed pre_push_task runs OK' do
    job = PushJob.find(34506)

    # This is an old pre-push task no longer valid for new push jobs,
    # but requesting a re-run of pre-push tasks for old jobs should
    # not fail.
    assert job.pre_push_tasks.include?('check_jira')

    job.run_pre_push_tasks

    assert_match %r{check_jira is an obsolete task}, job.log
    assert_valid job
  end

  def prepare_ovalcache
    # make sure we start with clean ovalcache directory
    directory = Rails.root.join(OvalTest.file_path)
    clean_ovalcache if File.directory?(directory)
    FileUtils.mkdir directory
  end

  def clean_ovalcache
    FileUtils.rm_r(Rails.root.join(OvalTest.file_path))
  end

  teardown do
    clean_ovalcache
  end

  # Creates and returns a valid, unsubmitted push job
  def unsubmitted_push_job
    e = RHBA.push_ready.first
    RhnLivePushJob.create!(:errata => e, :pushed_by => User.system,
                           :pub_options => {'push_files'=> true, 'push_metadata' => true})
  end

  # returns a hash of job_class_name vs job for errata
  # TODO: fill more details about the method
  def create_push_jobs(errata, pub_connection, job_classes = [RhnLivePushJob, CdnPushJob, FtpPushJob])
    # Create rhn_live, cdn_live and ftp push jobs for testings
    jobs = job_classes.each_with_object({}) do |klass, obj|
      class_name = klass.name
      job = klass.new(:errata => errata, :pushed_by => User.system)
      job.set_defaults
      job.save!
      job.create_pub_task(pub_connection)

      assert_equal 'WAITING_ON_PUB', job.status
      obj[class_name] = job
    end

    # Assert advisory transition PUSH_READY => IN_PUSH
    assert_equal State::PUSH_READY, errata.current_state_index.previous
    assert_equal State::IN_PUSH, errata.status
    jobs
  end

  # test BZ1102832
  test 'move errata status to REL_PREP if any live push job is failed' do
    e = @cdn_rhn_pushable
    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    # Do rhn push
    jobs = create_push_jobs(e, pc, [RhnLivePushJob])
    jobs['RhnLivePushJob'].pub_success!
    e.reload

    # Advisory status remain IN_PUSH because it still have pending cdn push
    assert_equal State::IN_PUSH, e.status

    # Do cdn push now and make it fails by canceling it
    jobs = create_push_jobs(e, pc, [CdnPushJob])
    jobs['CdnPushJob'].cancel!(pc, User.system)
    e.reload

    # Advisory should move back to PUSH_READY because of failed push jobs
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::PUSH_READY, e.status

    # Retry cdn push and success
    jobs = create_push_jobs(e, pc, [CdnPushJob])
    jobs['CdnPushJob'].pub_success!
    e.reload

    # All pushes are finished and advisory should move to SHIPPED_LIVE
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::SHIPPED_LIVE, e.status
  end

  test 'task_check_error does nothing on nochannel job failure' do
    e = @cdn_rhn_pushable
    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    # Do real rhn push
    rhn_job = create_push_jobs(e, pc, [RhnLivePushJob])['RhnLivePushJob']

    assert_equal State::IN_PUSH, e.reload.status

    # Now let's imagine this job has now failed, but didn't move advisory back to
    # REL_PREP for some reason
    rhn_job.status = 'FAILED'
    rhn_job.save!

    assert_equal State::IN_PUSH, e.reload.status

    # Trigger nochannel job...
    nochannel_job = RhnLivePushJob.new(:errata => e, :pushed_by => User.system)
    nochannel_job.set_defaults
    nochannel_job.pub_options['nochannel'] = true
    nochannel_job.pre_push_tasks = []
    nochannel_job.post_push_tasks = []
    nochannel_job.log = ''
    nochannel_job.save!

    # If the nochannel job fails...
    nochannel_job.mark_as_failed!('simulated error')

    # It should not have touched the errata status, even though task_check_error
    # would normally detect that a mandatory push job failed here
    assert_equal State::IN_PUSH, e.reload.status

    nochannel_job.log.lines.reject(&:blank?).tap do |lines|
      assert_equal 1, lines.length
      assert_match 'simulated error', lines[0]
    end
  end

  test 'task_check_error does nothing when other nochannel job failed' do
    e = @cdn_rhn_pushable
    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    # Do real RHN push
    rhn_job = create_push_jobs(e, pc, [RhnLivePushJob])['RhnLivePushJob']

    assert_equal State::IN_PUSH, e.reload.status

    # Do nochannel CDN push
    nochannel_job = CdnPushJob.new(:errata => e, :pushed_by => User.system)
    nochannel_job.set_defaults
    nochannel_job.pub_options['nochannel'] = true
    nochannel_job.pre_push_tasks = []
    nochannel_job.post_push_tasks = []
    nochannel_job.save!

    # Let's say the nochannel job fails
    nochannel_job.mark_as_failed!('simulated error')

    # It should not have touched the errata status
    assert_equal State::IN_PUSH, e.reload.status

    # Now the RHN job succeeds
    rhn_job.pub_success!

    # The RHN job's task_check_error should have run, and normally would have detected
    # a failed CDN job and moved advisory back, but not this time since it's a
    # nochannel job
    assert_equal State::IN_PUSH, e.reload.status
  end

  test 'nochannel scopes' do
    all_push_jobs = PushJob.unscoped
    not_nochannel_jobs = all_push_jobs.excluding_nochannel
    nochannel_jobs = all_push_jobs.nochannel

    assert_equal(
      all_push_jobs.map(&:id).sort,
      (not_nochannel_jobs + nochannel_jobs).map(&:id).sort)

    assert not_nochannel_jobs.length > 0
    assert nochannel_jobs.length > 0

    not_nochannel_jobs.each do |pj|
      refute pj.pub_options['nochannel'], pj.id.to_s
    end

    nochannel_jobs.each do |pj|
      assert pj.pub_options['nochannel'], pj.id.to_s
    end
  end

  test 'errata disable push target when in rel_prep' do
    e = @cdn_rhn_pushable
    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    # Do live pushes and failed
    jobs = create_push_jobs(e, pc)
    jobs.values.each{|job| job.cancel!(pc, User.system) }
    e.reload

    # Advisory should move back to PUSH_READY because of failed push jobs
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::PUSH_READY, e.status

    # Disable cdn push
    RHBA.any_instance.stubs(:supported_push_types).returns([:rhn_live])

    # Force memoize method to rerun
    e = Errata.find(e.id)

    # Retry rhn push and success
    jobs = create_push_jobs(e, pc, [RhnLivePushJob])
    jobs['RhnLivePushJob'].pub_success!
    e.reload

    # Advisory status should move to SHIPPED_LIVE without cdn push
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::SHIPPED_LIVE, e.status
  end

  test 'ftp push failure should not affect errata to move to shipped_live' do
    e = @cdn_rhn_pushable
    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    jobs = create_push_jobs(e, pc)

    # Cancel ftp push job
    jobs.delete('FtpPushJob').cancel!(pc, User.system)
    e.reload

    # Advisory status remain IN_PUSH because other live push jobs are running
    assert_equal State::IN_PUSH, e.status

    # Finishing the remaining push jobs now.
    jobs.values.each(&:pub_success!)

    e.reload

    # Ignore the ftp push job failure and move the advisory status to SHIPPED_LIVE
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::SHIPPED_LIVE, e.status
  end

  test 'post push failure should not prevent errata to move to shipped_live' do
    e = @cdn_rhn_pushable
    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    jobs = create_push_jobs(e, pc)

    # Prepare a non-mandatory task to fail on this job
    cdn_job = jobs['CdnPushJob']
    def cdn_job.task_update_bugzilla
      raise 'simulated error'
    end

    # Advisory status is IN_PUSH while jobs are running...
    assert_equal State::IN_PUSH, e.reload.status

    # Let all the jobs finish...
    # (Note: need to make CDN run after RHN or it won't trigger the failed task)
    %w[RhnLivePushJob CdnPushJob FtpPushJob].each do |type|
      jobs[type].pub_success!
    end

    e.reload

    # The advisory should have moved from IN_PUSH to SHIPPED_LIVE...
    assert_equal State::IN_PUSH, e.current_state_index.previous
    assert_equal State::SHIPPED_LIVE, e.status

    # ... despite that the CDN job went to POST_PUSH_FAILED.
    assert_equal 'POST_PUSH_FAILED', cdn_job.status
  end

  test 'push jobs log to DB even without save' do
    job1 = PushJob.find(34510)

    # start with empty log for this test
    job1.update_attribute(:log, '')

    # another reference to the same object
    job2 = PushJob.find(job1.id)

    assert_not_equal job1.object_id, job2.object_id

    Time.stubs(:now => Time.at(1425965356).getutc)

    job1.info 'a log from job1'
    job1.info 'another log from job1'
    job2.warn 'a log from job2'
    job1.warn 'final log from job1'

    # Although neither record has been saved, the log should have been
    # persisted.
    actual_log = PushJob.find(job1.id).log
    assert_equal <<-'eos'.strip, actual_log.strip
2015-03-10 05:29:16 +0000 a log from job1
2015-03-10 05:29:16 +0000 another log from job1
2015-03-10 05:29:16 +0000 a log from job2
2015-03-10 05:29:16 +0000 final log from job1
eos

    # job1 should also have this log already, even without a reload.
    # However, job2 needs a reload first, since it wasn't the last
    # writer to the log.
    assert_equal actual_log, job1.log
    assert_not_equal actual_log, job2.log
    assert_equal actual_log, job2.reload.log

    # saving the job should not affect the log.
    job1.status = 'FOO'
    job1.save!

    assert_equal 'FOO', job1.reload.status
    assert_equal actual_log, job1.log
  end

  test 'push job failing post-push tasks sends a notification' do
    fix_time
    RuntimeError.any_instance.stubs(:backtrace => ["<backtrace>"])

    pj = job_ready_for_post_push_tasks

    # Let a couple of post-push tasks fail, but most of them should work
    def pj.task_update_jira
      raise 'Refusing to communicate with non-free software'
    end
    def pj.task_update_bugzilla
      raise 'Oops, bugzilla did not work'
    end

    with_stubbed_const({:VERSION => '3.11.0-0'}, SystemVersion) do
      pj.run_post_push_tasks
    end

    mail = ActionMailer::Base.deliveries.last
    assert_testdata_equal "post_push_failed/push_job_#{pj.id}.txt", formatted_mail(mail)
  end

  test 'relative priorities' do
    errata_push_priority = lambda do |errata_type, push_job_type, options|
      job = push_job_type.first
      job.errata = errata_type.first
      job.pub_options = options
      job.default_priority
    end

    rhba_priority = lambda do |push_job_type|
      errata_push_priority[RHBA, push_job_type, {'push_files' => true}]
    end

    rhsa_priority = lambda do |push_job_type|
      errata_push_priority[RHSA, push_job_type, {'push_files' => true}]
    end

    rhba_nochannel_priority = lambda do |push_job_type|
      errata_push_priority[RHBA, push_job_type,
                           {'push_files' => true, 'nochannel' => true}]
    end

    rhsa_nochannel_priority = lambda do |push_job_type|
      errata_push_priority[RHSA, push_job_type,
                           {'push_files' => true, 'nochannel' => true}]
    end

    all_push_job_types = [
      RhnLivePushJob,
      RhnStagePushJob,
      CdnPushJob,
      CdnStagePushJob,
      FtpPushJob,
      AltsrcPushJob,
    ]

    all_push_job_types.each do |type|
      message = "assertion failed for #{type}"

      # For all types, security should always be higher priority than non-security
      # (true for both nochannel and regular push)
      assert rhba_priority[type] < rhsa_priority[type], message
      assert rhba_nochannel_priority[type] < rhsa_nochannel_priority[type], message

      # Any nochannel push should be lower priority than non-nochannel push
      assert rhsa_nochannel_priority[type] < rhba_priority[type], message

      # staging types should always be less than production types
      # (even security)
      unless type.name =~ /Stage/
        assert rhsa_priority[RhnStagePushJob] < rhba_priority[type], message
        assert rhsa_priority[CdnStagePushJob] < rhba_priority[type], message
      end
    end

    # live nochannel and stage non-nochannel have the same priority. (This has not been
    # explicitly requested, but testing so that it can't change without being noticed.)
    assert_equal rhsa_priority[RhnStagePushJob], rhsa_nochannel_priority[RhnLivePushJob]
    assert_equal rhba_priority[RhnStagePushJob], rhba_nochannel_priority[RhnLivePushJob]
    assert_equal rhsa_priority[CdnStagePushJob], rhsa_nochannel_priority[CdnPushJob]
    assert_equal rhba_priority[CdnStagePushJob], rhba_nochannel_priority[CdnPushJob]
  end

  test 'interrupting works as expected' do
    pj = PushJob.find(35510)
    assert_equal %w[reschedule_rhnqa mark_rhnqa_done], pj.post_push_tasks

    # make logs predictable
    Time.stubs(:now => Time.at(1425965356).getutc)
    Timeout::Error.any_instance.stubs(:backtrace => ['(backtrace)'])

    # start with empty logs
    pj.update_attribute(:log, '')

    # Simulate what happens when Delayed::Job interrupts a push job in
    # the middle of execution.
    def pj.task_mark_rhnqa_done
      self.status = 'TIMING_OUT'
      info 'About to simulate timeout.'
      raise Timeout::Error.new('execution expired')
    end

    # The timeout should propagate up through this level.
    assert_raises(Timeout::Error) do
      pj.pub_success!
    end

    # It should have persisted logs about the error.
    assert_equal <<-'eos'.strip, pj.reload.log.strip
2015-03-10 05:29:16 +0000 Pub completed.
2015-03-10 05:29:16 +0000 Running post push tasks.
2015-03-10 05:29:16 +0000 Running post push tasks: reschedule_rhnqa, mark_rhnqa_done
2015-03-10 05:29:16 +0000 Running mandatory tasks reschedule_rhnqa, mark_rhnqa_done
2015-03-10 05:29:16 +0000 Running task reschedule_rhnqa
2015-03-10 05:29:16 +0000 Running task mark_rhnqa_done
2015-03-10 05:29:16 +0000 About to simulate timeout.
2015-03-10 05:29:16 +0000 Error running task mark_rhnqa_done: Timeout::Error execution expired
(backtrace)
2015-03-10 05:29:16 +0000 Post push processing stopped. Error running tasks: execution expired
(backtrace)
2015-03-10 05:29:16 +0000 Mandatory post push tasks incomplete. Not marking job as completed
eos
  end

  test 'broken DB connection is handled reasonably' do
    # IMPORTANT: this test is not using transactional fixtures (due
    # to its need to temporarily disconnect from the DB).
    # Therefore, the test must not make any changes to fixture data,
    # or must undo any changes it makes.
    #
    # This test tries to simulate what happens when the process
    # handling a push job becomes so hopelessly broken that nothing
    # can be persisted to the DB.  The goal is to ensure that
    # meaningful and thorough evidence is left behind in such a case.

    pj = nil
    begin
      # make logs predictable
      Time.stubs(:now => Time.at(1425965356).getutc)
      NoMethodError.any_instance.stubs(:backtrace => ['(backtrace)'])

      e = Errata.find(19463)
      pj = RhnStagePushJob.create!(:errata => e, :pushed_by =>
        User.find_by_login_name!('errata-test@redhat.com'))

      def pj.logger
        MockLogger
      end

      pj.set_defaults
      # explicitly set the tasks to something (because normally the
      # order is undefined)
      pj.post_push_tasks = %w[reschedule_rhnqa mark_rhnqa_done]

      pj.save!

      def pj.task_mark_rhnqa_done
        ActiveRecord::Base.connection.disconnect!
        info 'This log message ought to fail due to DB disconnect.'
      end

      begin
        # It should be undefined exactly what kind of exception is
        # raised if the DB becomes disconnected, but it's most
        # practical to code the test to expect a particular error.
        assert_raises(NoMethodError) do
          pj.pub_success!
        end
      rescue Exception => e
        actual_error = e
      ensure
        ActiveRecord::Base.connection.reconnect!
      end

      # The persisted log should include messages up to the point that
      # the DB problem occurred...
      assert_equal <<-'eos'.strip, pj.reload.log.strip
2015-03-10 05:29:16 +0000 Pub completed.
2015-03-10 05:29:16 +0000 Running post push tasks.
2015-03-10 05:29:16 +0000 Running post push tasks: reschedule_rhnqa, mark_rhnqa_done
2015-03-10 05:29:16 +0000 Running mandatory tasks reschedule_rhnqa, mark_rhnqa_done
2015-03-10 05:29:16 +0000 Running task reschedule_rhnqa
2015-03-10 05:29:16 +0000 Running task mark_rhnqa_done
eos

      # The system logger should contain same messages up to the last
      # persisted message, and then have several more messages.
      logged = MockLogger.log
      idx = logged.find_index('Running task mark_rhnqa_done')
      assert_not_nil idx
      late_logged = logged[(idx+1)..-1]

      assert_equal <<-"eos".strip, late_logged.join("\n\n")
This log message ought to fail due to DB disconnect.

Failed to add log message to push job #{pj.id}: undefined method `escape' for nil:NilClass
(backtrace)

Error running task mark_rhnqa_done: NoMethodError undefined method `escape' for nil:NilClass
(backtrace)

Failed to add log message to push job #{pj.id}: undefined method `escape' for nil:NilClass
(backtrace)

Post push processing stopped. Error running tasks: undefined method `escape' for nil:NilClass
(backtrace)

Failed to add log message to push job #{pj.id}: undefined method `escape' for nil:NilClass
(backtrace)

Mandatory post push tasks incomplete. Not marking job as completed

Failed to add log message to push job #{pj.id}: undefined method `escape' for nil:NilClass
(backtrace)
eos
    ensure
      if pj && !pj.new_record?
        pj.destroy
      end
      MockLogger.reset
    end
  end

  # This "uses transaction" tells the test framework to _not_ use a
  # transaction when running this test.  (I guess it's supposed to
  # mean the test method shouldn't implicitly be wrapped in a
  # transaction because it already "uses a transaction", but that's
  # actually not true for this test...)
  uses_transaction 'test_broken_DB_connection_is_handled_reasonably'

  test 'submit_jobs_later uses multipush for targets which support it' do
    rhn_jobs = rhn_push_jobs_with_matching_pub_options
    cdn_jobs = cdn_push_jobs_with_matching_pub_options
    Settings.pub_use_multipush = [:rhn_live]

    # RHN jobs all expected to be submitted together, since that target is
    # configured as using multipush
    PushJob.expects(:submit_multipush).with(rhn_jobs.map(&:id)).once
    RhnLivePushJob.any_instance.expects(:submit_if_ready!).never

    # While CDN jobs are submitted individually as usual.
    #
    # (note: any_instance because it will be called on a reconstituted object,
    # not exactly the same instance as in cdn_jobs)
    CdnPushJob.any_instance.expects(:submit_if_ready!).twice

    force_sync_delayed_jobs do
      PushJob.submit_jobs_later(rhn_jobs + cdn_jobs)
    end
  end

  test 'submit_jobs_later uses multipush if only priorities differ' do
    cdn_jobs = cdn_push_jobs_with_different_priorities
    Settings.pub_use_multipush = [:cdn]

    # These jobs have different priorities but otherwise same pub
    # options, so should be submitted together using multipush
    PushJob.expects(:submit_multipush).with(cdn_jobs.map(&:id)).once

    force_sync_delayed_jobs do
      PushJob.submit_jobs_later(cdn_jobs)
    end
  end

  test 'submit_jobs_later does not use multipush for single job' do
    rhn_jobs = RhnLivePushJob.limit(1).to_a
    cdn_jobs = cdn_push_jobs_with_matching_pub_options
    Settings.pub_use_multipush = [:rhn_live, :cdn]

    # CDN jobs all expected to be submitted together
    PushJob.expects(:submit_multipush).with(cdn_jobs.map(&:id)).once
    CdnPushJob.any_instance.expects(:submit_if_ready!).never

    # The RHN job is submitted individually, even though it supports
    # multipush, since there was only one job
    RhnLivePushJob.any_instance.expects(:submit_if_ready!).once

    force_sync_delayed_jobs do
      PushJob.submit_jobs_later(rhn_jobs + cdn_jobs)
    end
  end

  test 'submit_jobs_later does not use multipush if pub does not support it' do
    rhn_jobs = rhn_push_jobs_with_matching_pub_options
    cdn_jobs = cdn_push_jobs_with_matching_pub_options
    Settings.pub_use_multipush = [:rhn_live]

    Push::DummyClient.any_instance.expects(:supports_multipush?).at_least_once.returns(false)

    # In this case, although :rhn_live target is set to use multipush, we won't
    # use it since the pub server doesn't support it
    PushJob.expects(:submit_multipush).never

    # All the jobs are submitted individually as usual.
    CdnPushJob.any_instance.expects(:submit_if_ready!).twice
    RhnLivePushJob.any_instance.expects(:submit_if_ready!).twice

    force_sync_delayed_jobs do
      PushJob.submit_jobs_later(rhn_jobs + cdn_jobs)
    end
  end

  test 'submit_jobs_later does not use multipush if pub_options do not match' do
    cdn_jobs = cdn_push_jobs_with_different_pub_options
    Settings.pub_use_multipush = [:cdn]

    # Multipush not used as the jobs have different pub_options
    PushJob.expects(:submit_multipush).never

    # All the jobs are submitted individually as usual.
    CdnPushJob.any_instance.expects(:submit_if_ready!).twice

    force_sync_delayed_jobs do
      PushJob.submit_jobs_later(cdn_jobs)
    end
  end

  test 'submit_multipush requires jobs to be the same target' do
    error = assert_raises(ArgumentError) do
      PushJob.submit_multipush([RhnLivePushJob.first, CdnPushJob.first])
    end
    assert_equal 'Attempt to submit multipush for mixed targets ["cdn", "rhn_live"]',
                 error.message
  end

  test 'submit_multipush collects expected jobs for submit' do
    skip_jobs = PushJob.where(:id => [1264, 1903])
    assert_equal [true, true], skip_jobs.map(&:skip_pub_task_and_post_process_only?)
    skip_jobs.each do |pj|
      pj.status = 'READY'
      pj.log = nil
      pj.save!
    end

    not_ready_jobs = PushJob.where(:id => [9145, 9826])
    assert_equal ['COMPLETE', 'COMPLETE'], not_ready_jobs.map(&:status)
    not_ready_jobs.each do |pj|
      pj.log = nil
      pj.save!
    end

    bad_pre_jobs = PushJob.where(:id => [11331, 11354])
    assert_equal [true, true], bad_pre_jobs.map(&:can_push?)
    bad_pre_jobs.each do |pj|
      pj.status = 'READY'
      pj.log = nil
      pj.pre_push_tasks = ['bogus']
      # need to save without validation since we set an invalid task
      pj.save!(:validate => false)
    end

    ready_jobs = PushJob.where(:id => [10485, 10327])
    ready_jobs.each do |pj|
      pj.status = 'READY'
      pj.save!
    end

    all_jobs = skip_jobs + not_ready_jobs + bad_pre_jobs + ready_jobs

    PushJob.expects(:create_multipush_pub_task).with do |client, submitted_jobs|
      # only the ready, non-skip jobs should be submitted
      assert_equal ready_jobs, submitted_jobs
      true
    end

    PushJob.submit_multipush(all_jobs)

    skip_jobs.each do |pj|
      # Jobs skipping pub should have gone straight to post-push tasks
      assert_match 'Running post push tasks', pj.reload.log
    end

    not_ready_jobs.each do |pj|
      # Not ready jobs should have skipped submitting
      assert_match 'Not submitting to pub because status is COMPLETE', pj.reload.log
    end

    bad_pre_jobs.each do |pj|
      # Should have tried and failed pre-push tasks on these jobs
      assert_match 'Error running task bogus:', pj.reload.log
    end
  end

  test 'submit_multipush submits as expected' do
    jobs = valid_multipush_jobs

    PushJob.submit_multipush(jobs)

    jobs.each(&:reload)
    jobs.each do |pj|
      # jobs should have been assigned the same ID
      assert_equal 100_000, pj.pub_task_id

      assert_equal 'WAITING_ON_PUB', pj.status

      # Log keeps track of multipush job
      assert_match 'Multipush, submitting 2 errata: 9829, 10801', pj.log
    end
  end

  test 'submit_multipush marks all jobs as failed if submit fails' do
    jobs = valid_multipush_jobs

    Push::DummyClient.any_instance.expects(:submit_multipush_jobs).returns(nil)

    error = assert_raises(RuntimeError) do
      PushJob.submit_multipush(jobs)
    end
    assert_match 'Unable to get a task id', error.message

    jobs.each(&:reload)
    jobs.each do |pj|
      assert_equal 'FAILED', pj.status

      # Log keeps track of multipush job
      assert_match 'Unable to get a task id from Pub; submission failed', pj.log
    end
  end

  # Returns a couple of jobs in a valid state for multipush submission.
  # The jobs are persisted and have empty logs.
  def valid_multipush_jobs
    jobs = PushJob.where(:id => [10485, 10327])
    jobs.each do |pj|
      pj.status = 'READY'
      pj.pub_task_id = nil
      pj.log = nil
      pj.save!
    end
  end

  # Returns two RHN push jobs with the same pub_options that
  # could potentially be grouped together for multipush
  def rhn_push_jobs_with_matching_pub_options
    rhn_jobs = RhnLivePushJob.find([1264, 3193]).to_a
    assert_equal 1, rhn_jobs.map(&:pub_options).uniq.size
    rhn_jobs
  end

  # Returns two CDN push jobs with the same pub_options that
  # could potentially be grouped together for multipush
  def cdn_push_jobs_with_matching_pub_options
    cdn_jobs = CdnPushJob.find([47959, 47972]).to_a
    assert_equal 1, cdn_jobs.map(&:pub_options).uniq.size
    cdn_jobs
  end

  # Returns two CDN push jobs with different priorities
  # but otherwise the same pub_options
  def cdn_push_jobs_with_different_priorities
    cdn_jobs = CdnPushJob.find([37571, 46703]).to_a
    pub_options = cdn_jobs.map(&:pub_options)
    assert_not_equal pub_options.first['priority'], pub_options.second['priority']
    assert_equal pub_options.first.except('priority'), pub_options.second.except('priority')
    cdn_jobs
  end

  # Returns two CDN push jobs with different pub_options
  def cdn_push_jobs_with_different_pub_options
    cdn_jobs = CdnPushJob.find([47972, 54017]).to_a
    assert_equal 2, cdn_jobs.map(&:pub_options).uniq.size
    cdn_jobs
  end

  test 'RHN nochannel push uses empty tasks' do
    nochannel_tasks_test RhnLivePushJob
  end

  test 'CDN nochannel push uses empty tasks' do
    nochannel_tasks_test CdnPushJob
  end

  def nochannel_tasks_test(klass)
    e = nochannel_push_errata
    pj = klass.new(:errata => e, :pushed_by => releng_user)
    pj.set_defaults
    pj.pub_options.merge!('nochannel' => true)

    refute pj.valid?
    assert_match 'must be empty', pj.errors[:pre_push_tasks].join
    assert_match 'must be empty', pj.errors[:post_push_tasks].join

    pj.pre_push_tasks = []
    pj.post_push_tasks = []

    assert_valid pj

    pj.save!

    # saving should not have implicitly added any tasks
    assert_equal [], pj.pre_push_tasks
    assert_equal [], pj.post_push_tasks
  end

  test 'push_details on nochannel push' do
    e = Errata.find(11112)
    assert_equal 'QE', e.status
    assert e.supports_rhn_live?
    assert e.supports_cdn?
    refute e.can_push_rhn_live?
    refute e.can_push_cdn?
    refute e.can_push_cdn_if_live_push_succeeds?

    test_job = lambda do |klass|
      push_job = klass.new(:errata => e, :pushed_by => User.system)
      push_job.pub_options = {'nochannel' => true, 'push_files' => true,
                              'push_metadata' => true}
      push_job.pre_push_tasks = []
      push_job.post_push_tasks = []
      push_job.save!

      # The response to the push_details method should take into account the fact that
      # this is a nochannel push, thus is allowed to push even in QE state.
      details = push_job.push_details
      assert_equal [], details['blockers']
      assert details['can']
    end

    # testing CDN job created both before and after RHN job, since there's different
    # code paths (but both are expected to be permitted for nochannel jobs)
    ActiveRecord::Base.transaction do
      test_job[CdnPushJob]
      raise ActiveRecord::Rollback
    end
    test_job[RhnLivePushJob]
    test_job[CdnPushJob]
  end

  test 'auto pre push failure notifies release-engineering' do
    errata = nochannel_push_errata

    # Stabilize logs
    fix_time

    push_by_user = lambda do |user|
      pj = RhnLivePushJob.new(:errata => errata, :pushed_by => user)
      pj.pub_options = {'nochannel' => true, 'push_files' => true}
      pj.pre_push_tasks = []
      pj.post_push_tasks = []

      assert pj.valid?

      pj.submit!
      pj
    end

    ActionMailer::Base.deliveries = []

    # Currently, this job is not considered an auto push, so it doesn't trigger the
    # notification
    pj = push_by_user[releng_user]
    assert_no_difference('ActionMailer::Base.deliveries.length') do
      ActiveRecord::Base.transaction do
        pj.mark_as_failed!('error')
      end
    end

    # However, the same kind of job but triggered by system user will trigger the
    # notification.
    pj = push_by_user[User.system]
    assert_difference('ActionMailer::Base.deliveries.length') do
      # Stabilize mail footer
      with_stubbed_const({:VERSION => 'x.y.z'}, SystemVersion) do
        ActiveRecord::Base.transaction do
          pj.mark_as_failed!('error')
        end
      end
    end

    mail = ActionMailer::Base.deliveries.last

    # Before we check the mail, wipe out the specific push job ID since that's
    # unpredictable
    body = mail.body.to_s
    mail.body = body.gsub(pj.id.to_s, '112233')

    assert_testdata_equal 'auto_prepush_failed/sample_job.txt', formatted_mail(mail)
  end

  test 'docker push moves errata status to IN_PUSH' do
    e = Errata.find(21100)
    assert e.has_docker?

    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    # Create push jobs
    jobs = create_push_jobs(e, pc, [CdnDockerPushJob])
    e.reload
    assert_state_change(e, :from => State::PUSH_READY, :to => State::IN_PUSH)

    # Cancel CDN docker push
    jobs['CdnDockerPushJob'].cancel!(pc, User.system)
    e.reload

    # Advisory should move back to PUSH_READY because of failed push job
    assert_state_change(e, :from => State::IN_PUSH, :to => State::PUSH_READY)
  end

  test 'failed docker push job moves errata status to REL_PREP' do
    e = Errata.find(21100)
    assert e.has_docker?

    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    # Create push jobs
    jobs = create_push_jobs(e, pc, [CdnPushJob, CdnDockerPushJob])
    e.reload
    assert_equal State::IN_PUSH, e.status

    # Cancel CDN push first
    jobs['CdnPushJob'].cancel!(pc, User.system)

    # Cancel CDN docker push
    jobs['CdnDockerPushJob'].cancel!(pc, User.system)
    e.reload

    # Advisory should move back to PUSH_READY because of failed push jobs
    assert_state_change(e, :from => State::IN_PUSH, :to => State::PUSH_READY)
  end

  test 'complete docker push job moves errata status to SHIPPED_LIVE' do
    e = Errata.find(21100)
    assert e.has_docker?

    pc = Push::PubClient.get_connection

    assert_equal State::PUSH_READY, e.status

    # Create push jobs
    jobs = create_push_jobs(e, pc, [CdnPushJob, CdnDockerPushJob])
    e.reload
    assert_equal State::IN_PUSH, e.status

    # CDN push completes first
    jobs['CdnPushJob'].pub_success!

    # CDN docker push completes after, no other outstanding jobs
    jobs['CdnDockerPushJob'].pub_success!
    e.reload

    # Advisory should move from IN_PUSH to SHIPPED_LIVE
    assert_state_change(e, :from => State::IN_PUSH, :to => State::SHIPPED_LIVE)
  end

  def nochannel_push_errata
    Errata.find(19463)
  end

  def assert_state_change(e, args)
    assert_match "Changed state from #{args[:from]} to #{args[:to]}", e.comments.last.text
    assert_equal args[:from], e.current_state_index.previous
    assert_equal args[:to], e.status
  end
end

class OvalTest
  (class << self; self; end).instance_eval do
    params = {
      :file_path => "test/data/ovalcache",
      :xmlrpc_url => "test.server.com",
      :xmlrpc_port => 8080,
      :xmlrpc_enabled => false,
      :public_url => "http://test.server.com/ovalcache/",}
    params.each_pair do |method_name, value|
      define_method method_name do
        value
      end
    end
  end
end
