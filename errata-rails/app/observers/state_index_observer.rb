class StateIndexObserver < ActiveRecord::Observer
  def after_create(idx)
    return if idx.initial_index?
    self.send("to_#{idx.current.downcase}", idx)
    ErrataActivity.create!(:what => 'status',
                           :removed => idx.previous,
                           :added => idx.current,
                           :errata => idx.errata)
    log_info_and_waived_guards idx
  end

  def after_rollback(idx)
    if error = transition_errors.delete(idx)
      text = "ERROR: #{error}\nAs a result, the advisory could not be moved to #{idx.current}."
      begin
        idx.errata.comments.create!(:who => idx.who, :text => text)
      rescue StandardError => e
        Rails.logger.warn "#{text}\nAdditionally, posting a comment on the advisory failed: #{e.message}"
      end
    end
  end

  private

  def transition_errors
    @transition_errors ||= {}
  end

  def log_info_and_waived_guards(idx)
    t = idx.state_transition
    rule_set = idx.errata.state_machine_rule_set

    waivers = []
    rule_set.guards_for_transition(t).waivable.each do |g|
      unless g.transition_ok?(idx.errata)
        waivers << g.failure_message(idx.errata)
      end
    end

    info_messages = []
    rule_set.guards_for_transition(t).informative.each do |g|
      unless g.transition_ok?(idx.errata)
        info_messages << "#{g.failure_message(idx.errata)} (optional)"
      end
    end

    return if waivers.empty? && info_messages.empty?
    msg = ''
    unless waivers.empty?
      msg += "The following state transition rules were waived by #{idx.who.to_s}:\n"
      msg += waivers.join("\n")
    end
    unless info_messages.empty?
      msg += "The following info messages were generated by the state change:\n"
      msg += info_messages.join("\n")
    end
    idx.errata.comments.create(:who => idx.who,
                               :text => msg)
  end


  def from_new_files(idx)
    previous_index = idx.prior_index
    errata = idx.errata

    if errata.supports_multiple_product_destinations?
      Notifier.multi_product_to_qe(errata).try(:deliver)
    end

    if previous_index.initial_index?
      NotifyPartnersJob.maybe_enqueue(idx)
      return
    end

    msg = ''

    dropped_bugs = DroppedBug.dropped_at_index(previous_index)
    unless dropped_bugs.empty?
      msg += "\n\n#{dropped_bugs.length} bugs removed:\n"
      msg += dropped_bugs.collect { |d| "bug #{d.bug_id}" }.join("\n")
    end

    added_bugs = FiledBug.added_at_index(previous_index)
    unless added_bugs.empty?
      msg += "\n\n#{added_bugs.length} bugs added:\n"
      msg += added_bugs.collect { |d| "bug #{d.bug_id}" }.join("\n")
    end

    dropped_mappings = errata.build_mapping_class.dropped_at_index(previous_index)
    dropped_builds = dropped_mappings.map(&:brew_build).uniq
    unless dropped_builds.empty?
      msg += "\n\n#{dropped_builds.length} builds removed:\n"
      msg += dropped_builds.collect { |b| b.nvr }.join("\n")
    end

    added_mappings = errata.build_mapping_class.added_at_index(previous_index)
    added_builds = added_mappings.map(&:brew_build).uniq
    unless added_builds.empty?
      msg += "\n\n#{added_builds.length} builds added:\n"
      msg += added_builds.collect { |b| b.nvr }.join("\n")
    end

    if msg.present?
      errata.comments.create(:who => idx.who, :text => msg)
      NotifyPartnersJob.maybe_enqueue(idx)
    end

    respin = !added_builds.empty? || !dropped_builds.empty?
    if respin
      errata.update_attribute(:respin_count, errata.respin_count + 1)
    end

    if errata.requires_tps?
      TPSLOG.info "Rescheduling TPS jobs due to advisory moving to QE."
      errata.tps_run.update_jobs_for_mappings!(added_mappings + dropped_mappings)
    end
  end

  def to_new_files(idx)
    TpsQueue.schedule_publication if idx.errata.requires_tps?
  end


  def to_qe(idx)
    if State::NEW_FILES == idx.previous
      from_new_files(idx)
      unless idx.errata.docs_approved_or_requested?
        # See Bug 809216
        idx.errata.request_docs_approval!
      end
    end
    TpsQueue.schedule_publication if idx.errata.requires_tps?

    # moving an errata to QE moves bugs to ON_QA for some products
    idx.errata.filed_bugs.each do |fb|
      Bugzilla::ModifiedToQaJob.enqueue fb, "advisory #{idx.errata.id} moving to state QE"
    end
  end

  def to_rel_prep(idx)
    # Could possibly now be eligible for pre-push.
    Push::PrepushTriggerJob.run_soon

    Push::RelPrepToPushReadyJob.enqueue_once
  end

  def to_push_ready(idx)
    Bugzilla::ReleasePendingJob.mark_bugs_as_release_pending idx.errata
    if idx.errata.release.is_async? && idx.previous != State::IN_PUSH && !idx.errata.is_end_to_end_test?
      begin
        Notifier.request_rhnlive_push(idx.errata).deliver
        idx.errata.comments.create(:who => idx.who,
                             :text => "A request to push this erratum live has been filed.")

      rescue => e
        transition_errors[idx] = "A problem occurred filing an rhn live push request: #{e.message}"
        raise e
      end
    end

  end

  def to_in_push(idx)
    # If part of a batch, remove pre-release errata from batch
    idx.errata.batch.try(:remove_prerelease_errata)

    # Lock the batch to prevent new errata from being assigned
    idx.errata.batch.try(:lock)
  end

  def to_shipped_live(idx)
    # NOTE: Need to switch send_later => delay when delayed_job is updated
    if idx.errata.is_pdc?
      PdcReleasedPackage.send_later(:make_released_packages_for_errata, idx.errata)
    else
      ReleasedPackage.send_later(:make_released_packages_for_errata, idx.errata)
    end


    if idx.errata.is_security? && !idx.who.in_role?('secalert')
      begin
        Notifier.rhsa_shipped_live(idx.errata, idx.who).deliver
        idx.errata.comments.create(:who => idx.who,
                                   :text => "A notification to Product Security team has been filed.")
      rescue => e
        transition_errors[idx] = "A problem occurred filing an RHSA push notification: #{e.message}"
        raise e
      end
    end

    # If part of a batch, may need to mark batch as released
    idx.errata.batch.try(:errata_shipped, idx.errata)
  end

  def to_dropped_no_ship(idx)
    idx.errata.filed_bugs.destroy_all
    idx.errata.filed_jira_issues.destroy_all
    idx.errata.release_components.update_all(:errata_id => nil)

    # If part of a batch, may need to mark batch as released
    idx.errata.batch.try(:errata_shipped, idx.errata)
  end
end
